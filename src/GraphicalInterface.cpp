// generated by Fast Light User Interface Designer (fluid) version 1.0300

#include "GraphicalInterface.h"

void GraphicalInterface::cb_window_main_i(Fl_Double_Window*, void*) {
  Exit();
}
void GraphicalInterface::cb_window_main(Fl_Double_Window* o, void* v) {
  ((GraphicalInterface*)(o->user_data()))->cb_window_main_i(o,v);
}

void GraphicalInterface::cb_menu_file_open_i(Fl_Menu_*, void*) {
  LoadModel();
}
void GraphicalInterface::cb_menu_file_open(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_file_open_i(o,v);
}

void GraphicalInterface::cb_menu_file_save_i(Fl_Menu_*, void*) {
  SaveModel();
}
void GraphicalInterface::cb_menu_file_save(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_file_save_i(o,v);
}

void GraphicalInterface::cb_menu_file_information_i(Fl_Menu_*, void*) {
  Information();
}
void GraphicalInterface::cb_menu_file_information(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_file_information_i(o,v);
}

void GraphicalInterface::cb_menu_file_quit_i(Fl_Menu_*, void*) {
  Exit();
}
void GraphicalInterface::cb_menu_file_quit(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_file_quit_i(o,v);
}

void GraphicalInterface::cb_menu_processing_analysis_i(Fl_Menu_*, void*) {
  Analysis();
}
void GraphicalInterface::cb_menu_processing_analysis(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_processing_analysis_i(o,v);
}

void GraphicalInterface::cb_menu_processing_coloring_i(Fl_Menu_*, void*) {
  ShowWindowColoring();
}
void GraphicalInterface::cb_menu_processing_coloring(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_processing_coloring_i(o,v);
}

void GraphicalInterface::cb_menu_processing_filtering_i(Fl_Menu_*, void*) {
  ShowWindowFiltering();
}
void GraphicalInterface::cb_menu_processing_filtering(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_processing_filtering_i(o,v);
}

void GraphicalInterface::cb_menu_processing_denoising_i(Fl_Menu_*, void*) {
  ShowWindowDenoising();
}
void GraphicalInterface::cb_menu_processing_denoising(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_processing_denoising_i(o,v);
}

void GraphicalInterface::cb_menu_processing_thresholding_i(Fl_Menu_*, void*) {
  ShowWindowThresholding();
}
void GraphicalInterface::cb_menu_processing_thresholding(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_processing_thresholding_i(o,v);
}

void GraphicalInterface::cb_menu_processing_simplification_i(Fl_Menu_*, void*) {
  ShowWindowSimplification();
}
void GraphicalInterface::cb_menu_processing_simplification(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_processing_simplification_i(o,v);
}

void GraphicalInterface::cb_menu_processing_test_i(Fl_Menu_*, void*) {
  TestProcessing();
}
void GraphicalInterface::cb_menu_processing_test(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_processing_test_i(o,v);
}

void GraphicalInterface::cb_menu_processing_reset_i(Fl_Menu_*, void*) {
  ResetProcessing();
}
void GraphicalInterface::cb_menu_processing_reset(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_processing_reset_i(o,v);
}

void GraphicalInterface::cb_menu_view_solid_i(Fl_Menu_*, void*) {
  ViewSolid();
}
void GraphicalInterface::cb_menu_view_solid(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_view_solid_i(o,v);
}

void GraphicalInterface::cb_menu_view_wireframe_i(Fl_Menu_*, void*) {
  ViewWireframe();
}
void GraphicalInterface::cb_menu_view_wireframe(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_view_wireframe_i(o,v);
}

void GraphicalInterface::cb_menu_view_vertices_i(Fl_Menu_*, void*) {
  ViewVertices();
}
void GraphicalInterface::cb_menu_view_vertices(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_view_vertices_i(o,v);
}

void GraphicalInterface::cb_menu_view_normals_i(Fl_Menu_*, void*) {
  ViewNormals();
}
void GraphicalInterface::cb_menu_view_normals(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_view_normals_i(o,v);
}

void GraphicalInterface::cb_menu_view_colors_i(Fl_Menu_*, void*) {
  ViewColors();
}
void GraphicalInterface::cb_menu_view_colors(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_view_colors_i(o,v);
}

void GraphicalInterface::cb_menu_view_texture_i(Fl_Menu_*, void*) {
  ViewTexture();
}
void GraphicalInterface::cb_menu_view_texture(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_view_texture_i(o,v);
}

void GraphicalInterface::cb_menu_view_smooth_i(Fl_Menu_*, void*) {
  ViewSmooth();
}
void GraphicalInterface::cb_menu_view_smooth(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_view_smooth_i(o,v);
}

void GraphicalInterface::cb_menu_view_antialiasing_i(Fl_Menu_*, void*) {
  ViewAntialiasing();
}
void GraphicalInterface::cb_menu_view_antialiasing(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_view_antialiasing_i(o,v);
}

void GraphicalInterface::cb_menu_view_background_color_i(Fl_Menu_*, void*) {
  ViewBackgroundColor();
}
void GraphicalInterface::cb_menu_view_background_color(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_view_background_color_i(o,v);
}

void GraphicalInterface::cb_menu_view_transformation_i(Fl_Menu_*, void*) {
  ShowWindowTransformation();
}
void GraphicalInterface::cb_menu_view_transformation(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_view_transformation_i(o,v);
}

void GraphicalInterface::cb_menu_help_about_i(Fl_Menu_*, void*) {
  About();
}
void GraphicalInterface::cb_menu_help_about(Fl_Menu_* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_menu_help_about_i(o,v);
}

Fl_Menu_Item GraphicalInterface::menu_menu_bar[] = {
 {"&File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Open...", 0xffbe,  (Fl_Callback*)GraphicalInterface::cb_menu_file_open, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Save...", 0xffbf,  (Fl_Callback*)GraphicalInterface::cb_menu_file_save, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Information", 0xffc0,  (Fl_Callback*)GraphicalInterface::cb_menu_file_information, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Quit", 0xff1b,  (Fl_Callback*)GraphicalInterface::cb_menu_file_quit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Processing", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Analysis", 0xffc1,  (Fl_Callback*)GraphicalInterface::cb_menu_processing_analysis, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Coloring", 0xffc2,  (Fl_Callback*)GraphicalInterface::cb_menu_processing_coloring, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Filtering", 0xffc3,  (Fl_Callback*)GraphicalInterface::cb_menu_processing_filtering, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Denoising", 0xffc4,  (Fl_Callback*)GraphicalInterface::cb_menu_processing_denoising, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Thresholding", 0xffc5,  (Fl_Callback*)GraphicalInterface::cb_menu_processing_thresholding, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Simplification", 0xffc6,  (Fl_Callback*)GraphicalInterface::cb_menu_processing_simplification, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Test", 0xffc7,  (Fl_Callback*)GraphicalInterface::cb_menu_processing_test, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Reset", 0xffc9,  (Fl_Callback*)GraphicalInterface::cb_menu_processing_reset, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&View", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Solid", 0x73,  (Fl_Callback*)GraphicalInterface::cb_menu_view_solid, 0, 6, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Wireframe", 0x77,  (Fl_Callback*)GraphicalInterface::cb_menu_view_wireframe, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Vertices", 0x76,  (Fl_Callback*)GraphicalInterface::cb_menu_view_vertices, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Normals", 0x6e,  (Fl_Callback*)GraphicalInterface::cb_menu_view_normals, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Colors", 0x63,  (Fl_Callback*)GraphicalInterface::cb_menu_view_colors, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Texture", 0x74,  (Fl_Callback*)GraphicalInterface::cb_menu_view_texture, 0, 130, FL_NORMAL_LABEL, 0, 14, 0},
 {"S&mooth shading", 0x6d,  (Fl_Callback*)GraphicalInterface::cb_menu_view_smooth, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Antialiasing", 0x61,  (Fl_Callback*)GraphicalInterface::cb_menu_view_antialiasing, 0, 130, FL_NORMAL_LABEL, 0, 14, 0},
 {"Background color", 0,  (Fl_Callback*)GraphicalInterface::cb_menu_view_background_color, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"T&ransformation", 0,  (Fl_Callback*)GraphicalInterface::cb_menu_view_transformation, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Help", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"&About", 0,  (Fl_Callback*)GraphicalInterface::cb_menu_help_about, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* GraphicalInterface::menu_file = GraphicalInterface::menu_menu_bar + 0;
Fl_Menu_Item* GraphicalInterface::menu_file_open = GraphicalInterface::menu_menu_bar + 1;
Fl_Menu_Item* GraphicalInterface::menu_file_save = GraphicalInterface::menu_menu_bar + 2;
Fl_Menu_Item* GraphicalInterface::menu_file_information = GraphicalInterface::menu_menu_bar + 3;
Fl_Menu_Item* GraphicalInterface::menu_file_quit = GraphicalInterface::menu_menu_bar + 4;
Fl_Menu_Item* GraphicalInterface::menu_processing = GraphicalInterface::menu_menu_bar + 6;
Fl_Menu_Item* GraphicalInterface::menu_processing_analysis = GraphicalInterface::menu_menu_bar + 7;
Fl_Menu_Item* GraphicalInterface::menu_processing_coloring = GraphicalInterface::menu_menu_bar + 8;
Fl_Menu_Item* GraphicalInterface::menu_processing_filtering = GraphicalInterface::menu_menu_bar + 9;
Fl_Menu_Item* GraphicalInterface::menu_processing_denoising = GraphicalInterface::menu_menu_bar + 10;
Fl_Menu_Item* GraphicalInterface::menu_processing_thresholding = GraphicalInterface::menu_menu_bar + 11;
Fl_Menu_Item* GraphicalInterface::menu_processing_simplification = GraphicalInterface::menu_menu_bar + 12;
Fl_Menu_Item* GraphicalInterface::menu_processing_test = GraphicalInterface::menu_menu_bar + 13;
Fl_Menu_Item* GraphicalInterface::menu_processing_reset = GraphicalInterface::menu_menu_bar + 14;
Fl_Menu_Item* GraphicalInterface::menu_view = GraphicalInterface::menu_menu_bar + 16;
Fl_Menu_Item* GraphicalInterface::menu_view_solid = GraphicalInterface::menu_menu_bar + 17;
Fl_Menu_Item* GraphicalInterface::menu_view_wireframe = GraphicalInterface::menu_menu_bar + 18;
Fl_Menu_Item* GraphicalInterface::menu_view_vertices = GraphicalInterface::menu_menu_bar + 19;
Fl_Menu_Item* GraphicalInterface::menu_view_normals = GraphicalInterface::menu_menu_bar + 20;
Fl_Menu_Item* GraphicalInterface::menu_view_colors = GraphicalInterface::menu_menu_bar + 21;
Fl_Menu_Item* GraphicalInterface::menu_view_texture = GraphicalInterface::menu_menu_bar + 22;
Fl_Menu_Item* GraphicalInterface::menu_view_smooth = GraphicalInterface::menu_menu_bar + 23;
Fl_Menu_Item* GraphicalInterface::menu_view_antialiasing = GraphicalInterface::menu_menu_bar + 24;
Fl_Menu_Item* GraphicalInterface::menu_view_background_color = GraphicalInterface::menu_menu_bar + 25;
Fl_Menu_Item* GraphicalInterface::menu_view_transformation = GraphicalInterface::menu_menu_bar + 26;
Fl_Menu_Item* GraphicalInterface::menu_help = GraphicalInterface::menu_menu_bar + 28;
Fl_Menu_Item* GraphicalInterface::menu_help_about = GraphicalInterface::menu_menu_bar + 29;

Fl_Menu_Item GraphicalInterface::menu_coloring_choice_details[] = {
 {"Geometrical", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Normal", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Color", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Texture", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void GraphicalInterface::cb_coloring_button_update_i(Fl_Button*, void*) {
  UpdateColoring();
}
void GraphicalInterface::cb_coloring_button_update(Fl_Button* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_coloring_button_update_i(o,v);
}

void GraphicalInterface::cb_filtering_button_update_i(Fl_Button*, void*) {
  UpdateFiltering();
}
void GraphicalInterface::cb_filtering_button_update(Fl_Button* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_filtering_button_update_i(o,v);
}

Fl_Menu_Item GraphicalInterface::menu_denoising_choice_type[] = {
 {"Geometric", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Color", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void GraphicalInterface::cb_denoising_button_update_i(Fl_Button*, void*) {
  UpdateDenoising();
}
void GraphicalInterface::cb_denoising_button_update(Fl_Button* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_denoising_button_update_i(o,v);
}

Fl_Menu_Item GraphicalInterface::menu_thresholding_choice_details[] = {
 {"Geometrical", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Normal", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Color", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Texture", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void GraphicalInterface::cb_thresholding_choice_morpho_i(Fl_Choice*, void*) {
  UpdateThresholdingMorpho();
}
void GraphicalInterface::cb_thresholding_choice_morpho(Fl_Choice* o, void* v) {
  ((GraphicalInterface*)(o->parent()->parent()->user_data()))->cb_thresholding_choice_morpho_i(o,v);
}

Fl_Menu_Item GraphicalInterface::menu_thresholding_choice_morpho[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Dilation", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Erosion", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Opening (dilation+erosion)", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Closing (erosion+dilation)", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void GraphicalInterface::cb_thresholding_button_update_i(Fl_Button*, void*) {
  UpdateThresholding();
}
void GraphicalInterface::cb_thresholding_button_update(Fl_Button* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_thresholding_button_update_i(o,v);
}

Fl_Menu_Item GraphicalInterface::menu_simplification_choice_details[] = {
 {"Geometrical", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Normal", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Color", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Texture", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void GraphicalInterface::cb_simplification_button_update_i(Fl_Button*, void*) {
  UpdateSimplification();
}
void GraphicalInterface::cb_simplification_button_update(Fl_Button* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_simplification_button_update_i(o,v);
}

void GraphicalInterface::cb_transformation_button_update_i(Fl_Button*, void*) {
  UpdateTransformation();
}
void GraphicalInterface::cb_transformation_button_update(Fl_Button* o, void* v) {
  ((GraphicalInterface*)(o->parent()->user_data()))->cb_transformation_button_update_i(o,v);
}

GraphicalInterface::GraphicalInterface() {
  { window_main = new Fl_Double_Window(500, 425, "Multiresolution Mesh Analysis");
    window_main->callback((Fl_Callback*)cb_window_main, (void*)(this));
    { menu_bar = new Fl_Menu_Bar(0, 0, 500, 25);
      menu_bar->down_box(FL_FLAT_BOX);
      menu_bar->menu(menu_menu_bar);
    } // Fl_Menu_Bar* menu_bar
    { visualizer = new Visualizer(0, 25, 500, 375);
      visualizer->box(FL_NO_BOX);
      visualizer->color(FL_BACKGROUND_COLOR);
      visualizer->selection_color(FL_BACKGROUND_COLOR);
      visualizer->labeltype(FL_NORMAL_LABEL);
      visualizer->labelfont(0);
      visualizer->labelsize(14);
      visualizer->labelcolor(FL_FOREGROUND_COLOR);
      visualizer->user_data((void*)(this));
      visualizer->align(Fl_Align(FL_ALIGN_CENTER));
      visualizer->when(FL_WHEN_RELEASE);
      Fl_Group::current()->resizable(visualizer);
      visualizer->window()->hotspot(visualizer);
    } // Visualizer* visualizer
    { status_bar = new Fl_Box(0, 400, 500, 25);
      status_bar->box(FL_UP_BOX);
      status_bar->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
    } // Fl_Box* status_bar
    window_main->end();
  } // Fl_Double_Window* window_main
  { window_message = new Fl_Double_Window(385, 70, "Message");
    window_message->box(FL_UP_BOX);
    window_message->color((Fl_Color)53);
    window_message->user_data((void*)(this));
    { text_message = new Fl_Box(5, 5, 375, 60, "Message");
      text_message->box(FL_ENGRAVED_BOX);
    } // Fl_Box* text_message
    window_message->set_modal();
    window_message->end();
  } // Fl_Double_Window* window_message
  { window_information = new Fl_Double_Window(325, 265, "Information");
    window_information->box(FL_UP_BOX);
    window_information->color((Fl_Color)53);
    window_information->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(5, 20, 315, 105, "Model");
      o->box(FL_ENGRAVED_BOX);
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(5, 145, 315, 115, "Details");
      o->box(FL_ENGRAVED_BOX);
      o->end();
    } // Fl_Group* o
    window_information->end();
  } // Fl_Double_Window* window_information
  { window_coloring = new Fl_Double_Window(290, 200, "Coloring");
    window_coloring->box(FL_UP_BOX);
    window_coloring->color((Fl_Color)53);
    window_coloring->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(5, 25, 280, 110, "Detail Coloring");
      o->box(FL_ENGRAVED_BOX);
      o->labelcolor(FL_SELECTION_COLOR);
      { coloring_slider_level = new Fl_Value_Slider(70, 35, 195, 30, "Level");
        coloring_slider_level->type(1);
        coloring_slider_level->color((Fl_Color)53);
        coloring_slider_level->maximum(20);
        coloring_slider_level->step(1);
        coloring_slider_level->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Value_Slider* coloring_slider_level
      { coloring_choice_details = new Fl_Choice(70, 70, 195, 30, "Details");
        coloring_choice_details->down_box(FL_BORDER_BOX);
        coloring_choice_details->menu(menu_coloring_choice_details);
      } // Fl_Choice* coloring_choice_details
      { coloring_smooth = new Fl_Check_Button(70, 105, 190, 30, "Smooth");
        coloring_smooth->down_box(FL_DOWN_BOX);
      } // Fl_Check_Button* coloring_smooth
      o->end();
    } // Fl_Group* o
    { coloring_button_update = new Fl_Button(5, 155, 280, 35, "&Update");
      coloring_button_update->tooltip("Denoise the model");
      coloring_button_update->down_box(FL_FLAT_BOX);
      coloring_button_update->callback((Fl_Callback*)cb_coloring_button_update);
    } // Fl_Button* coloring_button_update
    window_coloring->set_non_modal();
    window_coloring->end();
  } // Fl_Double_Window* window_coloring
  { window_filtering = new Fl_Double_Window(240, 315, "Filtering");
    window_filtering->box(FL_UP_BOX);
    window_filtering->color((Fl_Color)53);
    window_filtering->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(5, 25, 230, 225, "Frequency Bands");
      o->box(FL_ENGRAVED_BOX);
      o->labelcolor(FL_SELECTION_COLOR);
      { filtering_slider_1 = new Fl_Slider(30, 40, 30, 185, "Low");
        filtering_slider_1->color((Fl_Color)53);
        filtering_slider_1->minimum(2);
        filtering_slider_1->maximum(0);
        filtering_slider_1->step(0.1);
        filtering_slider_1->value(1);
      } // Fl_Slider* filtering_slider_1
      { filtering_slider_2 = new Fl_Slider(60, 40, 30, 185);
        filtering_slider_2->color((Fl_Color)53);
        filtering_slider_2->minimum(2);
        filtering_slider_2->maximum(0);
        filtering_slider_2->step(0.1);
        filtering_slider_2->value(1);
      } // Fl_Slider* filtering_slider_2
      { filtering_slider_3 = new Fl_Slider(90, 40, 30, 185);
        filtering_slider_3->color((Fl_Color)53);
        filtering_slider_3->minimum(2);
        filtering_slider_3->maximum(0);
        filtering_slider_3->step(0.1);
        filtering_slider_3->value(1);
      } // Fl_Slider* filtering_slider_3
      { filtering_slider_4 = new Fl_Slider(120, 40, 30, 185);
        filtering_slider_4->color((Fl_Color)53);
        filtering_slider_4->minimum(2);
        filtering_slider_4->maximum(0);
        filtering_slider_4->step(0.1);
        filtering_slider_4->value(1);
      } // Fl_Slider* filtering_slider_4
      { filtering_slider_5 = new Fl_Slider(150, 40, 30, 185);
        filtering_slider_5->color((Fl_Color)53);
        filtering_slider_5->minimum(2);
        filtering_slider_5->maximum(0);
        filtering_slider_5->step(0.1);
        filtering_slider_5->value(1);
      } // Fl_Slider* filtering_slider_5
      { filtering_slider_6 = new Fl_Slider(180, 40, 30, 185, "High");
        filtering_slider_6->color((Fl_Color)53);
        filtering_slider_6->minimum(2);
        filtering_slider_6->maximum(0);
        filtering_slider_6->step(0.1);
        filtering_slider_6->value(1);
        filtering_slider_6->align(Fl_Align(FL_ALIGN_BOTTOM_RIGHT));
      } // Fl_Slider* filtering_slider_6
      o->end();
    } // Fl_Group* o
    { filtering_button_update = new Fl_Button(5, 270, 230, 35, "&Update");
      filtering_button_update->tooltip("Filter the model");
      filtering_button_update->callback((Fl_Callback*)cb_filtering_button_update);
    } // Fl_Button* filtering_button_update
    window_filtering->set_non_modal();
    window_filtering->end();
  } // Fl_Double_Window* window_filtering
  { window_denoising = new Fl_Double_Window(290, 210, "Denoising");
    window_denoising->box(FL_UP_BOX);
    window_denoising->color((Fl_Color)53);
    window_denoising->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(5, 25, 280, 120, "Mesh Denoising");
      o->box(FL_ENGRAVED_BOX);
      o->labelcolor(FL_SELECTION_COLOR);
      { denoising_input_threshold = new Fl_Float_Input(80, 35, 110, 30, "Threshold");
        denoising_input_threshold->type(1);
      } // Fl_Float_Input* denoising_input_threshold
      { denoising_slider_level = new Fl_Value_Slider(80, 70, 195, 30, "Level");
        denoising_slider_level->type(1);
        denoising_slider_level->color((Fl_Color)53);
        denoising_slider_level->maximum(19);
        denoising_slider_level->step(1);
        denoising_slider_level->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Value_Slider* denoising_slider_level
      { denoising_choice_type = new Fl_Choice(80, 105, 195, 30, "Type");
        denoising_choice_type->down_box(FL_BORDER_BOX);
        denoising_choice_type->menu(menu_denoising_choice_type);
      } // Fl_Choice* denoising_choice_type
      o->end();
    } // Fl_Group* o
    { denoising_button_update = new Fl_Button(5, 165, 280, 35, "&Update");
      denoising_button_update->tooltip("Denoise the model");
      denoising_button_update->down_box(FL_FLAT_BOX);
      denoising_button_update->callback((Fl_Callback*)cb_denoising_button_update);
    } // Fl_Button* denoising_button_update
    window_denoising->set_non_modal();
    window_denoising->end();
  } // Fl_Double_Window* window_denoising
  { window_thresholding = new Fl_Double_Window(290, 320, "Thresholding");
    window_thresholding->box(FL_UP_BOX);
    window_thresholding->color((Fl_Color)53);
    window_thresholding->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(5, 25, 280, 120, "Detail Thresholding");
      o->box(FL_ENGRAVED_BOX);
      o->color((Fl_Color)48);
      o->selection_color((Fl_Color)48);
      o->labelcolor(FL_SELECTION_COLOR);
      { thresholding_input_threshold = new Fl_Float_Input(80, 35, 110, 30, "Threshold");
        thresholding_input_threshold->type(1);
      } // Fl_Float_Input* thresholding_input_threshold
      { thresholding_slider_level = new Fl_Value_Slider(80, 70, 195, 30, "Level");
        thresholding_slider_level->type(1);
        thresholding_slider_level->color((Fl_Color)53);
        thresholding_slider_level->maximum(19);
        thresholding_slider_level->step(1);
        thresholding_slider_level->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Value_Slider* thresholding_slider_level
      { thresholding_choice_details = new Fl_Choice(80, 105, 195, 30, "Details");
        thresholding_choice_details->down_box(FL_BORDER_BOX);
        thresholding_choice_details->menu(menu_thresholding_choice_details);
      } // Fl_Choice* thresholding_choice_details
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(5, 170, 280, 85, "Morphological Operator");
      o->box(FL_ENGRAVED_BOX);
      o->color((Fl_Color)48);
      o->labelcolor(FL_SELECTION_COLOR);
      { thresholding_choice_morpho = new Fl_Choice(75, 180, 205, 30, "Type");
        thresholding_choice_morpho->down_box(FL_BORDER_BOX);
        thresholding_choice_morpho->callback((Fl_Callback*)cb_thresholding_choice_morpho);
        thresholding_choice_morpho->menu(menu_thresholding_choice_morpho);
      } // Fl_Choice* thresholding_choice_morpho
      { thresholding_counter_iterations = new Fl_Counter(75, 220, 115, 25, "Iterations");
        thresholding_counter_iterations->type(1);
        thresholding_counter_iterations->minimum(1);
        thresholding_counter_iterations->maximum(100);
        thresholding_counter_iterations->step(1);
        thresholding_counter_iterations->value(1);
        thresholding_counter_iterations->align(Fl_Align(FL_ALIGN_LEFT));
        thresholding_counter_iterations->deactivate();
      } // Fl_Counter* thresholding_counter_iterations
      o->end();
    } // Fl_Group* o
    { thresholding_button_update = new Fl_Button(5, 275, 280, 35, "&Update");
      thresholding_button_update->tooltip("Denoise the model");
      thresholding_button_update->down_box(FL_FLAT_BOX);
      thresholding_button_update->color((Fl_Color)48);
      thresholding_button_update->selection_color((Fl_Color)48);
      thresholding_button_update->labelcolor(FL_GRAY0);
      thresholding_button_update->callback((Fl_Callback*)cb_thresholding_button_update);
    } // Fl_Button* thresholding_button_update
    window_thresholding->set_non_modal();
    window_thresholding->end();
  } // Fl_Double_Window* window_thresholding
  { window_simplification = new Fl_Double_Window(290, 235, "Simplification");
    window_simplification->box(FL_UP_BOX);
    window_simplification->color((Fl_Color)53);
    window_simplification->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(5, 25, 280, 145, "Mesh Simplification");
      o->box(FL_ENGRAVED_BOX);
      o->color((Fl_Color)48);
      o->selection_color((Fl_Color)48);
      o->labelcolor(FL_SELECTION_COLOR);
      { simplification_input_threshold = new Fl_Float_Input(80, 35, 110, 30, "Threshold");
        simplification_input_threshold->type(1);
      } // Fl_Float_Input* simplification_input_threshold
      { simplification_slider_level = new Fl_Value_Slider(80, 70, 195, 30, "Level");
        simplification_slider_level->type(1);
        simplification_slider_level->color((Fl_Color)53);
        simplification_slider_level->maximum(40);
        simplification_slider_level->step(1);
        simplification_slider_level->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Value_Slider* simplification_slider_level
      { simplification_choice_details = new Fl_Choice(80, 105, 195, 30, "Details");
        simplification_choice_details->down_box(FL_BORDER_BOX);
        simplification_choice_details->menu(menu_simplification_choice_details);
      } // Fl_Choice* simplification_choice_details
      { simplification_check_viewdependent = new Fl_Check_Button(80, 140, 155, 25, "View-dependent");
        simplification_check_viewdependent->down_box(FL_DOWN_BOX);
      } // Fl_Check_Button* simplification_check_viewdependent
      o->end();
    } // Fl_Group* o
    { simplification_button_update = new Fl_Button(5, 190, 280, 35, "&Update");
      simplification_button_update->tooltip("Denoise the model");
      simplification_button_update->down_box(FL_FLAT_BOX);
      simplification_button_update->color((Fl_Color)48);
      simplification_button_update->selection_color((Fl_Color)48);
      simplification_button_update->labelcolor(FL_GRAY0);
      simplification_button_update->callback((Fl_Callback*)cb_simplification_button_update);
    } // Fl_Button* simplification_button_update
    window_simplification->set_non_modal();
    window_simplification->end();
  } // Fl_Double_Window* window_simplification
  { window_transformation = new Fl_Double_Window(165, 205, "Transformation");
    window_transformation->box(FL_UP_BOX);
    window_transformation->color((Fl_Color)53);
    window_transformation->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(10, 25, 145, 120, "Rotation");
      o->box(FL_ENGRAVED_BOX);
      o->labelcolor(FL_SELECTION_COLOR);
      { transformation_input_rotation_x = new Fl_Float_Input(30, 35, 110, 30, "x");
        transformation_input_rotation_x->type(1);
      } // Fl_Float_Input* transformation_input_rotation_x
      { transformation_input_rotation_y = new Fl_Float_Input(30, 70, 110, 30, "y");
        transformation_input_rotation_y->type(1);
      } // Fl_Float_Input* transformation_input_rotation_y
      { transformation_input_rotation_z = new Fl_Float_Input(30, 105, 110, 30, "z");
        transformation_input_rotation_z->type(1);
      } // Fl_Float_Input* transformation_input_rotation_z
      o->end();
    } // Fl_Group* o
    { transformation_button_update = new Fl_Button(10, 160, 145, 35, "&Update");
      transformation_button_update->tooltip("Apply transformation to the visualization");
      transformation_button_update->down_box(FL_FLAT_BOX);
      transformation_button_update->color((Fl_Color)48);
      transformation_button_update->selection_color((Fl_Color)48);
      transformation_button_update->labelcolor(FL_GRAY0);
      transformation_button_update->callback((Fl_Callback*)cb_transformation_button_update);
    } // Fl_Button* transformation_button_update
    window_transformation->set_non_modal();
    window_transformation->end();
  } // Fl_Double_Window* window_transformation
  // Set the UI scheme
  Fl::get_system_colors();
  
  // Initialize data members
  mesh = 0;
  mesh_processing = 0;
  background_color = 1.0;
  
  // Set the title to the main window
  sprintf(title,"Multiresolution Mesh Analysis");
  window_main->label(title);
  
  // Set the status bar message
  sprintf(status,"");
  status_bar->label(status);
  
  // Apply the default settings to every window
  ResetWindows();
  
  // Set window size and position
  window_main->resize(100,100,900,700);
}

GraphicalInterface::~GraphicalInterface() {
  // Free memory
  if( mesh_processing ) delete mesh_processing;
  if( mesh ) delete mesh;
}

void GraphicalInterface::Show(int argc, char** argv) {
  // Show the main window
  window_main->show(argc, argv);
}

void GraphicalInterface::LoadModel() {
  // File selection dialog
  char* filename = fl_file_chooser("Load model...", "VRML Files (*.wrl)", "", 0);
  
  // File selection cancel
  if( filename == 0 ) return;
  
  // Delete previous mesh
  if( mesh ) {
  	delete mesh_processing;
  	mesh_processing = 0;
  	delete mesh;
  	mesh = 0;
  }
  
  // Set default main window title
  sprintf(title,"Multiresolution Mesh Analysis");
  window_main->label(title);
  
  // Set default status bar message
  sprintf(status,"");
  
  // Apply the default settings to every window
  ResetWindows();
  
  // Initialize the visualizer
  visualizer->SetModel(0);
  
  // Create new mesh
  mesh = new MultiresolutionMesh;
  
  // Refresh windows
  Fl::flush();
  Fl::check();
  
  // Message
  ShowMessage("Loading model, please wait...");
  
  // Load file
  if( !mesh->ReadFile(filename) )	{
  	// Error
  	HideMessage();
  	fl_alert( "Error while loading file \"%s\"",filename );
  	delete mesh;
  	mesh = 0;
  	return;
  }
  
  // Compute the bounding box of the model
  mesh->ComputeBoundingBox();
  
  //translation_vector = mesh->BoundingBox().Barycenter();
  // Translate the model to its gravity center
  //mesh->Translate( -mesh->BoundingBox().Barycenter() );
  // Scale the model to a cube of size 1
  //Vector3d model_size = mesh->BoundingBox().Length();
  //double 
  //scale_factor = 1.0 / std::max( std::max(model_size[0], model_size[1]), model_size[2] );
  //mesh->Scale( scale_factor );
  
  // Update the bounding box of the model
  //mesh->ComputeBoundingBox();
  
  // If the is a texture, convert the relative filename of the texture to an absolute filename
  if(mesh->TextureName().empty() == false) {
  	// Convert the texture filename to absolute path starting from the model absolute filename
  	std::string texture_filename = filename;
  	// Find the path in the filename
  #ifdef WIN32
  	int pos = texture_filename.find_last_of('\\');
  #else
  	int pos = texture_filename.find_last_of('/');
  #endif
  	if( pos != -1 ) {
  		// Remove the filename of the model in the path
  		texture_filename.erase(++pos);
  		// Add the texture name after the path
  		texture_filename += mesh->TextureName();
  		// Save the absolute filename of the texture in the mesh
  		mesh->TextureName() = texture_filename;
  	}
  }
  
  mesh->SetAllValid();
  mesh->CollectNeighbors();
  mesh->ComputeFaceNormals();
  mesh->ComputeVertexNormals();
  
  // Transfer model to the visualizer
  visualizer->SetModel( mesh );
  
  // Change the main window title according to the new file name
  sprintf(title,"Multiresolution Mesh Analysis - %s", fl_filename_name(filename));
  window_main->label(title);
  
  // Setup visualization options
  UpdateWindows();
  UpdateStatus();
  
  HideMessage();
}

void GraphicalInterface::SaveModel() {
  // File selection dialog
  char* filename = fl_file_chooser("Save model...", "VRML Files (*.wrl)", "", 0);
  
  // File selection cancel
  if( filename == 0 ) return;
  
  //static int num = 0;
  //char filename[255];
  //sprintf(filename,"level%02dt.wrl",num++);
  
  //Mesh* mesh_temp = new Mesh(*mesh);
  
  //
  //mesh_temp->Translate(translation_vector);
  //mesh_temp->Scale(1.0/scale_factor);
  
  // Message box
  ShowMessage("Saving model, please wait...");
  
  // Save file
  if( !mesh->WriteFile(filename, VRML_1_FILE) ) {
  	HideMessage();
  	fl_alert( "Error while saving file \"%s\"",filename );
  	return;
  }
  
  // Hide the message window and activate all other windows
  HideMessage();
  UpdateStatus();
  
  //delete mesh_temp;
}

void GraphicalInterface::Analysis() {
  if(mesh->LevelNumber()!=0) return;
  if( mesh_processing != 0 ) {
  	delete mesh_processing;
  	mesh_processing = 0;
  }
  
  // Message
  ShowMessage("Decomposing model, please wait...");
  
  // Analysis
  if( !mesh->Analysis(20) ) {
  	// Error
  	delete mesh;
  	mesh = 0;
  	HideMessage();
  	fl_alert("Error during the decomposition of the model");
  	return;
  }
  
  // Message
  ShowMessage("Reconstructing model, please wait...");
  
  // Synthesis
  if( !mesh->Synthesis() ) {
  	// Error
  	delete mesh;
  	mesh = 0;
  	HideMessage();
  	fl_alert("Error during the reconstruction of the model");
  	return;
  }
  
  // Compute normals
  mesh->ComputeFaceNormals();
  mesh->ComputeVertexNormals();
  
  // Message
  ShowMessage("Preparing multiresolution processing, please wait...");
  
  // Initialize the "processor"
  mesh_processing = new MultiresolutionProcessing( mesh );
  
  // Update windows
  UpdateWindows();
  
  // Update status bar
  UpdateStatus();
  
  //
  HideMessage();
}

bool GraphicalInterface::Information() {
  // Test if a model has been loaded and analysed
  if( mesh==0 || mesh_processing==0 ) return false;
  
  // Compute multiresolution model statistics
  mesh_processing->Statistics();
}

void GraphicalInterface::Exit() {
  exit(0);
}

void GraphicalInterface::UpdateStatus() {
  if( !mesh ) sprintf(status,"");
  else sprintf(status, "Level: %d ~ Vertices: %d ~ Faces: %d", mesh->CurrentLevelNumber(), mesh->ValidVertexNumber(), mesh->ValidFaceNumber());
  status_bar->redraw();
}

void GraphicalInterface::UpdateWindows() {
  if( !mesh ) {
  	// Apply the default settings to every window
  	ResetWindows();
  	return;
  }
  
  //
  // Setup visualization options
  //
  
  // Activate menu processing
  menu_file_save->activate();
  menu_file_information->activate();
  menu_processing->activate();
  menu_view->activate();
  
  // Check for colors
  if( mesh->ColorNumber() == mesh->VertexNumber() ) {
  	menu_view_colors->set();
  	menu_view_colors->activate();
  //	menu_options_choice_details[3].show();
  	menu_coloring_choice_details[2].show();
  	menu_thresholding_choice_details[2].show();
  	menu_simplification_choice_details[2].show();
  	visualizer->EnableColors(true);
  }
  else {
  	menu_view_colors->clear();
  	menu_view_colors->deactivate();
  //	menu_options_choice_details[3].hide();
  	menu_coloring_choice_details[2].hide();
  	menu_thresholding_choice_details[2].hide();
  	menu_simplification_choice_details[2].hide();
  	visualizer->EnableColors(false);
  }
  
  // Check for texture
  if( (mesh->TextureNumber()!=0) && (mesh->TextureName().empty()==false) ) {
  	menu_view_texture->set();
  	menu_view_texture->activate();
  //	menu_options_choice_details[4].show();
  	menu_coloring_choice_details[3].show();
  	menu_thresholding_choice_details[3].show();
  	menu_simplification_choice_details[3].show();
  	visualizer->EnableTexture(true);
  }
  else {
  	menu_view_texture->clear();
  	menu_view_texture->deactivate();
  //	menu_options_choice_details[4].hide();
  	menu_coloring_choice_details[3].hide();
  	menu_thresholding_choice_details[3].hide();
  	menu_simplification_choice_details[3].hide();
  	visualizer->EnableTexture(false);
  }
}

void GraphicalInterface::ResetWindows() {
  // Menu
  menu_file_save->deactivate();
  menu_file_information->deactivate();
  menu_processing->deactivate();
  menu_view->deactivate();
  
  // Visualizer
  visualizer->EnableSolid(true);
  visualizer->EnableWireframe(false);
  visualizer->EnableVertices(false);
  visualizer->EnableNormals(false);
  visualizer->EnableColors(false);
  visualizer->EnableTexture(false);
  visualizer->EnableSmooth(false);
  visualizer->EnableAntialiasing(false);
  visualizer->EnableDetailsGeometrical(false);
  visualizer->EnableDetailsNormal(false);
  visualizer->EnableDetailsColor(false);
  visualizer->EnableDetailsTexture(false);
  visualizer->ToggleSimplification(false);
  
  // View Menu
  menu_view_solid->set();
  menu_view_wireframe->clear();
  menu_view_vertices->clear();
  menu_view_normals->clear();
  menu_view_colors->clear();
  menu_view_colors->deactivate();
  menu_view_texture->clear();
  menu_view_texture->deactivate();
  menu_view_smooth->clear();
  menu_view_antialiasing->clear();
  
  // Window Coloring
  coloring_slider_level->value(0);
  coloring_choice_details->value(0);
  coloring_smooth->value(0);
  menu_coloring_choice_details[2].hide();
  menu_coloring_choice_details[3].hide();
  
  // Window Filtering
  filtering_slider_1->value(1);
  filtering_slider_2->value(1);
  filtering_slider_3->value(1);
  filtering_slider_4->value(1);
  filtering_slider_5->value(1);
  filtering_slider_6->value(1);
  
  // Window Denoising
  denoising_input_threshold->value("0.05");
  denoising_slider_level->value(0);
  denoising_choice_type->value(0);
  
  // Window Thresholding
  thresholding_input_threshold->value("0.05");
  thresholding_slider_level->value(0);
  thresholding_choice_details->value(0);
  thresholding_choice_morpho->value(0);
  thresholding_counter_iterations->value(1);
  thresholding_counter_iterations->deactivate();
  
  // Window Simplification
  simplification_input_threshold->value("0.05");
  simplification_slider_level->value(0);
  simplification_choice_details->value(0);
  menu_simplification_choice_details[2].hide();
  menu_simplification_choice_details[3].hide();
}

void GraphicalInterface::ResetProcessing() {
  // Check
  if( !mesh ) return;
  if(mesh->LevelNumber()==0) return;
  
  // Restore original model
  ShowMessage("Restoring original model, please wait...");
  
  // Restore original model, and reset processings to their default values
  mesh_processing->Reset();
  
  // Check for colors
  UpdateWindows();
  
  // Update status bar
  UpdateStatus();
  
  // Update visualization
  visualizer->ToggleSimplification(false);
  visualizer->ToggleColorBar(false);
  visualizer->UpdateModel();
  
  // Hide the message box
  HideMessage();
}

void GraphicalInterface::ShowWindowColoring() {
  if(mesh->LevelNumber()==0) return;
  if(window_coloring->shown()) window_coloring->hide();
  else window_coloring->show();
}

void GraphicalInterface::ShowWindowFiltering() {
  if(mesh->LevelNumber()==0) return;
  if(window_filtering->shown()) window_filtering->hide();
  else window_filtering->show();
}

void GraphicalInterface::ShowWindowDenoising() {
  if(mesh->LevelNumber()==0) return;
  if(window_denoising->shown()) window_denoising->hide();
  else window_denoising->show();
}

void GraphicalInterface::ShowWindowThresholding() {
  if(mesh->LevelNumber()==0) return;
  if(window_thresholding->shown()) window_thresholding->hide();
  else window_thresholding->show();
}

void GraphicalInterface::ShowWindowSimplification() {
  if(mesh->LevelNumber()==0) return;
  if(window_simplification->shown()) window_simplification->hide();
  else window_simplification->show();
}

void GraphicalInterface::ShowWindowTransformation() {
  if(window_transformation->shown()) window_transformation->hide();
  else window_transformation->show();
}

void GraphicalInterface::ViewSolid() {
  visualizer->EnableSolid( menu_view_solid->value() );
}

void GraphicalInterface::ViewWireframe() {
  visualizer->EnableWireframe( menu_view_wireframe->value() );
}

void GraphicalInterface::ViewVertices() {
  visualizer->EnableVertices( menu_view_vertices->value() );
}

void GraphicalInterface::ViewNormals() {
  visualizer->EnableNormals( menu_view_normals->value() );
}

void GraphicalInterface::ViewColors() {
  visualizer->EnableColors( menu_view_colors->value() );
}

void GraphicalInterface::ViewTexture() {
  visualizer->EnableTexture( menu_view_texture->value() );
}

void GraphicalInterface::ViewSmooth() {
  visualizer->EnableSmooth( menu_view_smooth->value() );
}

void GraphicalInterface::ViewAntialiasing() {
  visualizer->EnableAntialiasing( menu_view_antialiasing->value() );
}

void GraphicalInterface::ViewBackgroundColor() {
  // Pop up the color chooser window
  fl_color_chooser("Color Chooser", background_color[0], background_color[1], background_color[2]);
  // Set the background color of the OpenGL visualizer
  visualizer->SetBackgroundColor(background_color);
}

void GraphicalInterface::OptionTexture2Colors() {
  // Is there a mesh ?
  if( !mesh ) return;
  
  // Is there a texture ?
  if( mesh->TextureNumber()!=mesh->VertexNumber() || mesh->TextureName().empty() ) return;
  
  // Message
  ShowMessage("Converting texture to vertex colors, please wait...");
  
  // Convert the texture image to vertex colors
  mesh->ConvertTexture2Colors();
  
  // Message
  ShowMessage("Decomposing model, please wait...");
  
  // Analyse the mesh again (to manage new color attributes)
  if( !mesh->Analysis(20) ) {
  	// Error
  	delete mesh;
  	mesh = 0;
  	HideMessage();
  	fl_alert("Error during the decomposition of the model");
  	return;
  }
  
  // Message
  ShowMessage("Reconstructing model, please wait...");
  
  // Synthesis
  if( !mesh->Synthesis() ) {
  	// Error
  	delete mesh;
  	mesh = 0;
  	HideMessage();
  	fl_alert("Error during the reconstruction of the model");
  	return;
  }
  
  // Message
  ShowMessage("Preparing visualization, please wait...");
  
  // Transfer model to the visualizer
  visualizer->SetModel( mesh );
  
  // Setup visualization options
  UpdateWindows();
  UpdateStatus();
  
  // Hide the message box
  HideMessage();
}

void GraphicalInterface::UpdateColoring() {
  // Check mesh
  if( !mesh ) return;
  
  // Get parameters
  int level_number = (int)coloring_slider_level->value();
  DetailType type = (DetailType)coloring_choice_details->value();
  bool smooth = (bool)coloring_smooth->value();
  ShowMessage("Coloring the model, please wait...");
  
  // Apply thresholding
  mesh_processing->Color( type, level_number, smooth );
  
  // Display colors
  menu_view_colors->set();
  menu_view_colors->activate();
  visualizer->EnableColors( true );
  
  // Update visualization
  visualizer->ToggleColorBar(true);
  visualizer->UpdateModel();
  
  // Update status bar
  UpdateStatus();
  
  // Hide the message box
  HideMessage();
}

void GraphicalInterface::UpdateFiltering() {
  // Check mesh
  if( !mesh ) return;
  
  // Get parameters
  std::vector<double> filter_bands(6);
  filter_bands[0] = filtering_slider_1->value();
  filter_bands[1] = filtering_slider_2->value();
  filter_bands[2] = filtering_slider_3->value();
  filter_bands[3] = filtering_slider_4->value();
  filter_bands[4] = filtering_slider_5->value();
  filter_bands[5] = filtering_slider_6->value();
  
  // Show message
  ShowMessage("Applying filter, please wait...");
  
  // Apply denoising
  mesh_processing->Filter( filter_bands );
  
  // Update visualization
  visualizer->UpdateModel();
  
  // Hide the message box
  HideMessage();
}

void GraphicalInterface::UpdateDenoising() {
  // Check mesh
  if( !mesh ) return;
  
  // Get parameters
  double threshold = atof(denoising_input_threshold->value());
  int level_number = (int)denoising_slider_level->value();
  bool soft_thresholding = (bool)denoising_choice_type->value();
  
  // Show message
  ShowMessage("Applying denoising filter, please wait...");
  
  // Apply denoising
  mesh_processing->Denoise( threshold, level_number, soft_thresholding );
  
  // Update visualization
  visualizer->UpdateModel(false);
  
  // Update status bar
  UpdateStatus();
  
  // Hide the message box
  HideMessage();
}

void GraphicalInterface::UpdateThresholding() {
  // Check mesh
  if(mesh == 0) return;
  
  // Get parameters
  double threshold = atof(thresholding_input_threshold->value());
  int level_number = (int)thresholding_slider_level->value();
  SegmentationType type = (SegmentationType)thresholding_choice_morpho->value();
  int iterations = (int)thresholding_counter_iterations->value();
  
  // Show message
  ShowMessage("Applying thresholding filter, please wait...");
  
  // Apply thresholding
  mesh_processing->Threshold( threshold, level_number, type, iterations );
  
  // Display colors
  menu_view_colors->set();
  menu_view_colors->activate();
  visualizer->EnableColors( true );
  
  // Update visualization
  visualizer->UpdateModel();
  
  // Update status bar
  UpdateStatus();
  
  // Hide the message box
  HideMessage();
}

void GraphicalInterface::UpdateSimplification() {
  // Check 
  if(mesh == 0) return;
  
  // Get parameters
  double threshold = atof(simplification_input_threshold->value());
  int level_number = (int)simplification_slider_level->value();
  DetailType type = (DetailType)simplification_choice_details->value();
  
  // Show message
  ShowMessage("Applying simplification, please wait...");
  
  // Apply simplification
  if( simplification_check_viewdependent->value() ) {
  	mesh_processing->Simplify( threshold, level_number, type, true, visualizer->GetViewport() );
  }
  else {
  	mesh_processing->Simplify( threshold, level_number, type );
  }
  
  // Update status bar
  sprintf(status, "Adaptive reconstruction ~ Vertices: %d ~ Faces: %d", mesh->ValidVertexNumber(), mesh->ValidFaceNumber());
  status_bar->redraw();
  
  // Update visualization
  visualizer->ToggleSimplification(true);
  visualizer->UpdateModel();
  
  // Hide the message box
  HideMessage();
}

void GraphicalInterface::UpdateThresholdingMorpho() {
  // If a morphological operator has been chosen: activate iteration number widget
  if( thresholding_choice_morpho->value() != 0 ) thresholding_counter_iterations->activate();
  // Otherwise, deactivate iteration number widget
  else thresholding_counter_iterations->deactivate();
}

void GraphicalInterface::UpdateTransformation() {
  // Check 
  if(mesh == 0) return;
  
  // Get parameters
  double rotx = atof(transformation_input_rotation_x->value());
  double roty = atof(transformation_input_rotation_y->value());
  double rotz = atof(transformation_input_rotation_z->value());
  
  // Apply transformation
  visualizer->SetTransformation(rotx, roty, rotz);
}

void GraphicalInterface::ShowMessage(const char* msg) {
  // Deactivate windows
  //window_main->deactivate();
  window_coloring->deactivate();
  window_filtering->deactivate();
  window_denoising->deactivate();
  window_thresholding->deactivate();
  window_simplification->deactivate();
  
  // Initialize window cursors to wait state
  window_main->cursor(FL_CURSOR_WAIT);
  window_coloring->cursor(FL_CURSOR_WAIT);
  window_filtering->cursor(FL_CURSOR_WAIT);
  window_denoising->cursor(FL_CURSOR_WAIT);
  window_thresholding->cursor(FL_CURSOR_WAIT);
  window_simplification->cursor(FL_CURSOR_WAIT);
  window_message->cursor(FL_CURSOR_WAIT);
  
  // Deactivate menu
  menu_bar->deactivate();
  
  // Update message
  //text_message->label(msg);
  
  // Show message window
  //window_message->show();
  
  sprintf(status, "%s", msg);
  //status_bar->redraw();
  
  // Refresh all the windows
  Fl::flush();
  Fl::check();
}

void GraphicalInterface::HideMessage() {
  // Activate windows
  //window_main->activate();
  window_coloring->activate();
  window_filtering->activate();
  window_denoising->activate();
  window_thresholding->activate();
  window_simplification->activate();
  
  // Initialize window cursors to default state
  window_main->cursor(FL_CURSOR_DEFAULT);
  window_coloring->cursor(FL_CURSOR_DEFAULT);
  window_filtering->cursor(FL_CURSOR_DEFAULT);
  window_denoising->cursor(FL_CURSOR_DEFAULT);
  window_thresholding->cursor(FL_CURSOR_DEFAULT);
  window_simplification->cursor(FL_CURSOR_DEFAULT);
  
  // Activate menu
  menu_bar->activate();
  
  // Hide message window
  //window_message->hide();
  //sprintf(status, "");
  
  // Refresh all the windows
  Fl::flush();
  Fl::check();
}

void GraphicalInterface::About() {
  fl_message("Multresolution Mesh Analysis v1.0\nCopyright 2002-2005 by Michael Roy\nGNU General Public License");
}

void GraphicalInterface::TestProcessing() {
  // Check mesh
  if(mesh == 0) return;
  
  // Show message
  ShowMessage("Applying test processing, please wait...");
  
  // Apply thresholding
  mesh_processing->Test();
  
  // Display colors
  menu_view_colors->set();
  menu_view_colors->activate();
  visualizer->EnableColors( true );
  
  // Update visualization
  visualizer->UpdateModel();
  
  // Update status bar
  UpdateStatus();
  
  // Hide the message box
  HideMessage();
}
